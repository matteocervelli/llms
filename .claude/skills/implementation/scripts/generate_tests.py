#!/usr/bin/env python3
"""
Test Generation Tool

Generates test scaffolding for Python modules, including:
- Test file structure
- Test fixtures
- Basic test cases
- Mock setup
- Coverage configuration

Usage:
    python generate_tests.py --module src/tools/feature/core.py
    python generate_tests.py --module src/tools/feature/core.py --output tests/unit/
    python generate_tests.py --class FeatureService --methods create,update,delete

Author: Generated by skill_builder
License: MIT
"""

import argparse
import ast
import sys
from pathlib import Path
from typing import List, Dict, Optional, Set
from dataclasses import dataclass


@dataclass
class FunctionInfo:
    """Information about a function."""

    name: str
    args: List[str]
    has_return: bool
    is_async: bool
    docstring: Optional[str] = None


@dataclass
class ClassInfo:
    """Information about a class."""

    name: str
    methods: List[FunctionInfo]
    docstring: Optional[str] = None


class ModuleAnalyzer:
    """Analyzes Python modules to extract testable functions and classes."""

    def __init__(self, module_path: Path):
        """
        Initialize analyzer with module path.

        Args:
            module_path: Path to Python module to analyze
        """
        self.module_path = module_path
        self.tree = None

    def analyze(self) -> Dict[str, any]:
        """
        Analyze module and extract structure.

        Returns:
            Dictionary with functions, classes, and imports
        """
        if not self.module_path.exists():
            raise FileNotFoundError(f"Module not found: {self.module_path}")

        source = self.module_path.read_text()
        self.tree = ast.parse(source)

        return {
            "functions": self._extract_functions(),
            "classes": self._extract_classes(),
            "imports": self._extract_imports(),
        }

    def _extract_functions(self) -> List[FunctionInfo]:
        """Extract top-level functions from module."""
        functions = []

        for node in ast.walk(self.tree):
            # Only top-level functions (not methods)
            if isinstance(node, ast.FunctionDef) and isinstance(node, ast.FunctionDef):
                # Skip private functions
                if node.name.startswith("_"):
                    continue

                # Extract function info
                args = [arg.arg for arg in node.args.args]
                has_return = any(isinstance(n, ast.Return) for n in ast.walk(node))
                is_async = isinstance(node, ast.AsyncFunctionDef)
                docstring = ast.get_docstring(node)

                functions.append(
                    FunctionInfo(
                        name=node.name,
                        args=args,
                        has_return=has_return,
                        is_async=is_async,
                        docstring=docstring,
                    )
                )

        return functions

    def _extract_classes(self) -> List[ClassInfo]:
        """Extract classes and their methods from module."""
        classes = []

        for node in self.tree.body:
            if isinstance(node, ast.ClassDef):
                # Skip private classes
                if node.name.startswith("_"):
                    continue

                methods = []
                for item in node.body:
                    if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                        # Skip private methods and __init__
                        if item.name.startswith("_") and item.name != "__init__":
                            continue

                        args = [arg.arg for arg in item.args.args]
                        has_return = any(isinstance(n, ast.Return) for n in ast.walk(item))
                        is_async = isinstance(item, ast.AsyncFunctionDef)
                        docstring = ast.get_docstring(item)

                        methods.append(
                            FunctionInfo(
                                name=item.name,
                                args=args,
                                has_return=has_return,
                                is_async=is_async,
                                docstring=docstring,
                            )
                        )

                docstring = ast.get_docstring(node)
                classes.append(ClassInfo(name=node.name, methods=methods, docstring=docstring))

        return classes

    def _extract_imports(self) -> List[str]:
        """Extract import statements for identifying mock candidates."""
        imports = []

        for node in ast.walk(self.tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append(alias.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.append(node.module)

        return list(set(imports))


class TestGenerator:
    """Generates test files from module analysis."""

    def __init__(self, module_info: Dict[str, any], output_dir: Path):
        """
        Initialize generator.

        Args:
            module_info: Module analysis from ModuleAnalyzer
            output_dir: Directory to write test files
        """
        self.module_info = module_info
        self.output_dir = output_dir

    def generate(self, module_name: str, module_path: Path) -> Path:
        """
        Generate test file for module.

        Args:
            module_name: Name of module being tested
            module_path: Original module path

        Returns:
            Path to generated test file
        """
        test_filename = f"test_{module_name}.py"
        test_path = self.output_dir / test_filename

        content = self._generate_test_content(module_name, module_path)

        test_path.write_text(content)
        print(f"Generated test file: {test_path}")

        return test_path

    def _generate_test_content(self, module_name: str, module_path: Path) -> str:
        """Generate content of test file."""
        # Build import path from module_path
        import_path = self._get_import_path(module_path, module_name)

        # Generate imports section
        imports = self._generate_imports(import_path)

        # Generate fixtures
        fixtures = self._generate_fixtures()

        # Generate function tests
        function_tests = self._generate_function_tests(self.module_info["functions"])

        # Generate class tests
        class_tests = self._generate_class_tests(self.module_info["classes"])

        # Combine all sections
        content = f'''"""
Tests for {module_name} module.

This file contains unit tests for the {module_name} module.
"""

{imports}

{fixtures}

{function_tests}

{class_tests}
'''

        return content

    def _get_import_path(self, module_path: Path, module_name: str) -> str:
        """
        Convert file path to Python import path.

        Args:
            module_path: Path to module file
            module_name: Name of module

        Returns:
            Import path string (e.g., "src.tools.feature.core")
        """
        # Convert path to import-style string
        parts = list(module_path.parts)

        # Find src or project root
        if "src" in parts:
            idx = parts.index("src")
            parts = parts[idx:]
        elif "lib" in parts:
            idx = parts.index("lib")
            parts = parts[idx:]

        # Remove .py extension and join
        import_parts = [p for p in parts if p != module_name + ".py"]
        import_parts.append(module_name)

        return ".".join(import_parts)

    def _generate_imports(self, import_path: str) -> str:
        """Generate import statements."""
        imports = """import pytest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
"""

        # Add module import
        imports += f"\nfrom {import_path} import *\n"

        return imports

    def _generate_fixtures(self) -> str:
        """Generate common fixtures."""
        return '''
# Fixtures
@pytest.fixture
def sample_data():
    """Sample data for tests."""
    return {"key": "value", "number": 42}


@pytest.fixture
def temp_file(tmp_path):
    """Temporary file for file I/O tests."""
    file_path = tmp_path / "test_file.txt"
    file_path.write_text("test content")
    return file_path
'''

    def _generate_function_tests(self, functions: List[FunctionInfo]) -> str:
        """Generate test cases for functions."""
        if not functions:
            return ""

        tests = "\n\n# Function Tests\n"

        for func in functions:
            # Skip if already starts with test_
            if func.name.startswith("test_"):
                continue

            tests += self._generate_function_test(func)

        return tests

    def _generate_function_test(self, func: FunctionInfo) -> str:
        """Generate test for a single function."""
        # Prepare arguments
        args_str = ", ".join(func.args) if func.args else ""

        # Generate async test if needed
        decorator = "@pytest.mark.asyncio\n" if func.is_async else ""
        async_keyword = "async " if func.is_async else ""
        await_keyword = "await " if func.is_async else ""

        # Generate test
        test = f'''
{decorator}def {async_keyword}test_{func.name}_success():
    """Test {func.name} with valid input."""
    # Arrange
    # TODO: Set up test data

    # Act
    result = {await_keyword}{func.name}({args_str})

    # Assert
    # TODO: Add assertions
    assert result is not None


{decorator}def {async_keyword}test_{func.name}_error_handling():
    """Test {func.name} error handling."""
    # Arrange
    # TODO: Set up invalid data

    # Act & Assert
    with pytest.raises(Exception):  # TODO: Specify exception type
        {await_keyword}{func.name}({args_str})
'''

        return test

    def _generate_class_tests(self, classes: List[ClassInfo]) -> str:
        """Generate test cases for classes."""
        if not classes:
            return ""

        tests = "\n\n# Class Tests\n"

        for cls in classes:
            tests += self._generate_class_test(cls)

        return tests

    def _generate_class_test(self, cls: ClassInfo) -> str:
        """Generate test for a single class."""
        test = f'''
class Test{cls.name}:
    """Tests for {cls.name}."""

    @pytest.fixture
    def instance(self):
        """Create {cls.name} instance for testing."""
        # TODO: Mock dependencies if needed
        return {cls.name}()
'''

        # Generate test for each method
        for method in cls.methods:
            if method.name == "__init__":
                continue

            decorator = "    @pytest.mark.asyncio\n" if method.is_async else ""
            async_keyword = "async " if method.is_async else ""
            await_keyword = "await " if method.is_async else ""

            test += f'''
{decorator}    def {async_keyword}test_{method.name}_success(self, instance):
        """Test {method.name} with valid input."""
        # Arrange
        # TODO: Set up test data

        # Act
        result = {await_keyword}instance.{method.name}()

        # Assert
        # TODO: Add assertions
        assert result is not None
'''

        return test


class TestScaffolder:
    """
    Main scaffolder for generating test structure.

    Orchestrates analysis and generation of test files.
    """

    def __init__(self, project_root: Path):
        """
        Initialize scaffolder.

        Args:
            project_root: Root directory of project
        """
        self.project_root = project_root
        self.tests_dir = project_root / "tests"

    def scaffold_for_module(self, module_path: Path, output_dir: Optional[Path] = None) -> Path:
        """
        Generate test scaffold for a module.

        Args:
            module_path: Path to module to generate tests for
            output_dir: Optional custom output directory

        Returns:
            Path to generated test file
        """
        print(f"Scaffolding tests for: {module_path}")

        # Analyze module
        analyzer = ModuleAnalyzer(module_path)
        module_info = analyzer.analyze()

        print(
            f"Found: {len(module_info['functions'])} functions, "
            f"{len(module_info['classes'])} classes"
        )

        # Determine output directory
        if output_dir is None:
            output_dir = self.tests_dir / "unit"

        output_dir.mkdir(parents=True, exist_ok=True)

        # Generate tests
        generator = TestGenerator(module_info, output_dir)
        module_name = module_path.stem
        test_path = generator.generate(module_name, module_path)

        return test_path

    def scaffold_for_class(self, class_name: str, methods: List[str], output_path: Path) -> None:
        """
        Generate test scaffold for a specific class.

        Args:
            class_name: Name of class to test
            methods: List of method names to generate tests for
            output_path: Path to output test file
        """
        print(f"Generating tests for class: {class_name}")
        print(f"Methods: {', '.join(methods)}")

        content = f'''"""
Tests for {class_name}.
"""

import pytest
from unittest.mock import Mock, MagicMock

# TODO: Update import path
from module import {class_name}


class Test{class_name}:
    """Tests for {class_name}."""

    @pytest.fixture
    def instance(self):
        """Create {class_name} instance for testing."""
        # TODO: Mock dependencies
        return {class_name}()
'''

        for method in methods:
            content += f'''
    def test_{method}_success(self, instance):
        """Test {method} with valid input."""
        # Arrange
        # TODO: Set up test data

        # Act
        result = instance.{method}()

        # Assert
        # TODO: Add assertions
        assert result is not None

    def test_{method}_error(self, instance):
        """Test {method} error handling."""
        # Arrange
        # TODO: Set up invalid data

        # Act & Assert
        with pytest.raises(Exception):  # TODO: Specify exception type
            instance.{method}()
'''

        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content)
        print(f"Generated: {output_path}")


def main():
    """Main entry point for CLI."""
    parser = argparse.ArgumentParser(
        description="Generate test scaffolding for Python modules",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate tests for a module
  python generate_tests.py --module src/tools/feature/core.py

  # Specify output directory
  python generate_tests.py --module src/core.py --output tests/unit/

  # Generate tests for specific class
  python generate_tests.py --class FeatureService --methods create,update,delete

  # Generate integration test structure
  python generate_tests.py --module src/service.py --integration
        """,
    )

    parser.add_argument(
        "--module",
        type=Path,
        help="Path to Python module to generate tests for",
    )

    parser.add_argument(
        "--output",
        type=Path,
        help="Output directory for test files (default: tests/unit/)",
    )

    parser.add_argument(
        "--class", dest="class_name", type=str, help="Generate tests for specific class"
    )

    parser.add_argument("--methods", type=str, help="Comma-separated list of methods to test")

    parser.add_argument(
        "--integration",
        action="store_true",
        help="Generate integration test structure",
    )

    parser.add_argument(
        "--project-root",
        type=Path,
        default=Path.cwd(),
        help="Root directory of project (default: current directory)",
    )

    args = parser.parse_args()

    # Initialize scaffolder
    scaffolder = TestScaffolder(project_root=args.project_root)

    # Generate tests based on arguments
    if args.module:
        # Generate for module
        output_dir = args.output
        if args.integration:
            output_dir = output_dir or (scaffolder.tests_dir / "integration")
        else:
            output_dir = output_dir or (scaffolder.tests_dir / "unit")

        test_path = scaffolder.scaffold_for_module(args.module, output_dir)
        print(f"✅ Test scaffold generated: {test_path}")

    elif args.class_name and args.methods:
        # Generate for class
        methods = [m.strip() for m in args.methods.split(",")]
        output_path = args.output or (scaffolder.tests_dir / f"test_{args.class_name.lower()}.py")

        scaffolder.scaffold_for_class(args.class_name, methods, output_path)
        print(f"✅ Class tests generated: {output_path}")

    else:
        parser.print_help()
        print("\n⚠️  Please specify --module or --class with --methods")
        sys.exit(1)


if __name__ == "__main__":
    main()
