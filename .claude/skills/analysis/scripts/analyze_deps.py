#!/usr/bin/env python3
"""
Dependency Analysis Tool

Analyzes project dependencies for a given feature, identifying:
- Required external packages
- Internal module dependencies
- Potential conflicts
- Version compatibility issues
- Security vulnerabilities (via pip-audit if available)

Usage:
    python analyze_deps.py --feature feature-name [--output report.md]
    python analyze_deps.py --check-conflicts
    python analyze_deps.py --list-outdated

Author: Generated by skill_builder
License: MIT
"""

import argparse
import json
import re
import subprocess
import sys
from importlib.metadata import distributions, version
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from urllib.request import urlopen
from urllib.error import URLError


class DependencyAnalyzer:
    """
    Analyzes project dependencies and identifies potential issues.

    Attributes:
        project_root: Path to the project root directory
        requirements_file: Path to requirements.txt or pyproject.toml
    """

    def __init__(self, project_root: Optional[Path] = None):
        """
        Initialize the dependency analyzer.

        Args:
            project_root: Root directory of the project (defaults to current dir)
        """
        self.project_root = project_root or Path.cwd()
        self.requirements_file = self._find_requirements_file()
        self._installed_packages = self._get_installed_packages()

    def _find_requirements_file(self) -> Optional[Path]:
        """
        Locate requirements.txt or pyproject.toml in the project.

        Returns:
            Path to requirements file or None if not found
        """
        candidates = [
            self.project_root / "requirements.txt",
            self.project_root / "pyproject.toml",
            self.project_root / "requirements" / "base.txt",
            self.project_root / "requirements" / "requirements.txt",
        ]

        for candidate in candidates:
            if candidate.exists():
                return candidate

        return None

    def _get_installed_packages(self) -> Dict[str, str]:
        """
        Get all installed packages and their versions.

        Returns:
            Dictionary mapping package names to versions
        """
        packages = {}
        for dist in distributions():
            name = dist.metadata["Name"]
            ver = dist.metadata["Version"]
            packages[name.lower()] = ver
        return packages

    def _parse_requirements_txt(self, file_path: Path) -> Dict[str, str]:
        """
        Parse requirements.txt file for package specifications.

        Args:
            file_path: Path to requirements.txt

        Returns:
            Dictionary mapping package names to version specifiers
        """
        requirements = {}
        try:
            content = file_path.read_text()
            for line in content.splitlines():
                line = line.strip()
                # Skip comments and empty lines
                if not line or line.startswith("#"):
                    continue
                # Skip -e editable installs
                if line.startswith("-e"):
                    continue
                # Parse package name and version specifier
                match = re.match(r"^([a-zA-Z0-9_-]+)(.*)$", line)
                if match:
                    pkg_name = match.group(1).lower()
                    version_spec = match.group(2).strip()
                    requirements[pkg_name] = version_spec
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        return requirements

    def _parse_pyproject_toml(self, file_path: Path) -> Dict[str, str]:
        """
        Parse pyproject.toml for dependencies.

        Args:
            file_path: Path to pyproject.toml

        Returns:
            Dictionary mapping package names to version specifiers
        """
        requirements = {}
        try:
            content = file_path.read_text()
            # Simple regex parsing for dependencies section
            in_deps = False
            for line in content.splitlines():
                line = line.strip()
                if line.startswith("[project.dependencies]") or line.startswith("dependencies ="):
                    in_deps = True
                    continue
                if in_deps:
                    if line.startswith("["):
                        break
                    # Parse dependency line: "package>=version"
                    match = re.match(r'"([a-zA-Z0-9_-]+)(.*)\"', line)
                    if match:
                        pkg_name = match.group(1).lower()
                        version_spec = match.group(2).strip()
                        requirements[pkg_name] = version_spec
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        return requirements

    def analyze_feature_dependencies(self, feature_name: str) -> Dict[str, List[str]]:
        """
        Analyze dependencies required for a specific feature.

        Args:
            feature_name: Name of the feature being implemented

        Returns:
            Dictionary with 'external' and 'internal' dependency lists
        """
        print(f"Analyzing dependencies for feature: {feature_name}")

        # Find Python files related to the feature
        feature_files = self._find_feature_files(feature_name)

        # Extract imports from those files
        external_deps, internal_deps = self._extract_imports(feature_files)

        dependencies = {
            "external": sorted(external_deps),
            "internal": sorted(internal_deps),
        }

        return dependencies

    def _find_feature_files(self, feature_name: str) -> List[Path]:
        """
        Find Python files potentially related to a feature.

        Args:
            feature_name: Feature name to search for

        Returns:
            List of Python file paths
        """
        feature_files = []
        # Search for files containing the feature name
        for py_file in self.project_root.rglob("*.py"):
            # Skip test files and virtual environments
            if "venv" in str(py_file) or "__pycache__" in str(py_file):
                continue
            # Check if feature name appears in file path or content
            if feature_name.replace("-", "_") in str(py_file).lower():
                feature_files.append(py_file)
        return feature_files

    def _extract_imports(self, files: List[Path]) -> Tuple[Set[str], Set[str]]:
        """
        Extract imports from Python files.

        Args:
            files: List of Python files to analyze

        Returns:
            Tuple of (external_packages, internal_modules)
        """
        external = set()
        internal = set()

        for file_path in files:
            try:
                content = file_path.read_text()
                for line in content.splitlines():
                    line = line.strip()
                    # Match import statements
                    if line.startswith("import ") or line.startswith("from "):
                        parts = line.split()
                        if len(parts) >= 2:
                            module = parts[1].split(".")[0]
                            # Check if it's an installed package
                            if module.lower() in self._installed_packages:
                                external.add(module.lower())
                            elif not module.startswith("_"):
                                # Likely internal module
                                internal.add(parts[1])
            except Exception as e:
                print(f"Warning: Failed to parse {file_path}: {e}")

        return external, internal

    def check_conflicts(self) -> List[Tuple[str, str, str]]:
        """
        Check for dependency version conflicts.

        Returns:
            List of tuples: (package, required_version, installed_version)
        """
        print("Checking for dependency conflicts...")

        if not self.requirements_file:
            print("Warning: No requirements file found")
            return []

        conflicts = []

        # Parse requirements
        if self.requirements_file.name == "requirements.txt":
            requirements = self._parse_requirements_txt(self.requirements_file)
        else:
            requirements = self._parse_pyproject_toml(self.requirements_file)

        # Check each requirement
        for pkg_name, version_spec in requirements.items():
            if pkg_name in self._installed_packages:
                installed_ver = self._installed_packages[pkg_name]
                # Simple version check (doesn't handle complex specifiers)
                if version_spec and not self._version_matches(installed_ver, version_spec):
                    conflicts.append((pkg_name, version_spec, installed_ver))
            else:
                # Package not installed
                conflicts.append((pkg_name, version_spec, "not installed"))

        return conflicts

    def _version_matches(self, installed: str, spec: str) -> bool:
        """
        Check if installed version matches specification.

        Args:
            installed: Installed version string
            spec: Version specification (e.g., ">=2.0.0")

        Returns:
            True if version matches specification
        """
        # Simple implementation - just check for exact match or >=
        if not spec or spec == "*":
            return True
        if spec.startswith("=="):
            return installed == spec[2:].strip()
        if spec.startswith(">="):
            # Simplified version comparison
            required = spec[2:].strip()
            return installed >= required
        # Default to True for complex specifiers
        return True

    def list_outdated(self) -> List[Tuple[str, str, str]]:
        """
        List outdated dependencies by querying PyPI.

        Returns:
            List of tuples: (package, current_version, latest_version)
        """
        print("Checking for outdated dependencies (this may take a moment)...")

        outdated = []

        for pkg_name, current_ver in self._installed_packages.items():
            try:
                latest_ver = self._get_latest_version(pkg_name)
                if latest_ver and latest_ver != current_ver:
                    # Simple version comparison
                    if self._is_newer_version(latest_ver, current_ver):
                        outdated.append((pkg_name, current_ver, latest_ver))
            except Exception as e:
                # Skip packages that fail PyPI lookup
                continue

        return outdated

    def _get_latest_version(self, package_name: str) -> Optional[str]:
        """
        Query PyPI for the latest version of a package.

        Args:
            package_name: Name of the package

        Returns:
            Latest version string or None
        """
        try:
            url = f"https://pypi.org/pypi/{package_name}/json"
            with urlopen(url, timeout=5) as response:
                data = json.loads(response.read())
                return data["info"]["version"]
        except (URLError, KeyError, json.JSONDecodeError):
            return None

    def _is_newer_version(self, v1: str, v2: str) -> bool:
        """
        Compare two version strings (simplified).

        Args:
            v1: First version
            v2: Second version

        Returns:
            True if v1 > v2
        """
        try:
            # Simple lexicographic comparison (works for most cases)
            parts1 = [int(x) for x in v1.split(".")[:3]]
            parts2 = [int(x) for x in v2.split(".")[:3]]
            return parts1 > parts2
        except (ValueError, IndexError):
            return False

    def generate_report(self, feature_name: str, output_file: Optional[Path] = None) -> str:
        """
        Generate a dependency analysis report in Markdown format.

        Args:
            feature_name: Name of the feature being analyzed
            output_file: Optional path to write report to

        Returns:
            Report content as string
        """
        dependencies = self.analyze_feature_dependencies(feature_name)
        conflicts = self.check_conflicts()
        outdated = self.list_outdated()

        report = f"""# Dependency Analysis Report: {feature_name}

## External Dependencies

{self._format_dependencies(dependencies["external"])}

## Internal Dependencies

{self._format_dependencies(dependencies["internal"])}

## Conflicts Detected

{self._format_conflicts(conflicts)}

## Outdated Dependencies

{self._format_outdated(outdated)}

## Recommendations

{self._generate_recommendations(conflicts, outdated)}

## Installation Commands

{self._generate_install_commands(conflicts)}

---
Generated by analyze_deps.py
"""

        if output_file:
            output_file.write_text(report)
            print(f"Report written to: {output_file}")

        return report

    def _format_dependencies(self, deps: List[str]) -> str:
        """Format dependency list as Markdown."""
        if not deps:
            return "*No dependencies detected*\n"

        return "\n".join(f"- `{dep}`" for dep in deps)

    def _format_conflicts(self, conflicts: List[Tuple[str, str, str]]) -> str:
        """Format conflicts as Markdown."""
        if not conflicts:
            return "✅ No conflicts detected\n"

        lines = ["⚠️ **Conflicts found:**\n"]
        for package, required, installed in conflicts:
            lines.append(f"- **{package}**: requires `{required}`, " f"installed `{installed}`")

        return "\n".join(lines)

    def _format_outdated(self, outdated: List[Tuple[str, str, str]]) -> str:
        """Format outdated dependencies as Markdown."""
        if not outdated:
            return "✅ All dependencies up-to-date\n"

        lines = ["📦 **Updates available:**\n"]
        for package, current, latest in outdated:
            lines.append(f"- **{package}**: `{current}` → `{latest}`")

        return "\n".join(lines)

    def _generate_recommendations(
        self,
        conflicts: List[Tuple[str, str, str]],
        outdated: List[Tuple[str, str, str]],
    ) -> str:
        """Generate recommendations based on analysis."""
        recommendations = []

        if conflicts:
            recommendations.append(
                "- 🔴 **Resolve version conflicts** before proceeding with " "implementation"
            )

        if len(outdated) > 10:
            recommendations.append(
                "- 🟡 **Review outdated dependencies** - consider updating " "major versions"
            )

        if not conflicts and not outdated:
            recommendations.append(
                "- ✅ **No immediate action required** - dependencies are " "up-to-date"
            )

        if not recommendations:
            recommendations.append("- Review external dependencies for security advisories")

        return "\n".join(recommendations)

    def _generate_install_commands(self, conflicts: List[Tuple[str, str, str]]) -> str:
        """Generate pip install commands for missing dependencies."""
        if not conflicts:
            return "*No missing dependencies*\n"

        lines = ["```bash"]
        for package, required, installed in conflicts:
            if installed == "not installed":
                if required:
                    lines.append(f"pip install {package}{required}")
                else:
                    lines.append(f"pip install {package}")
        lines.append("```")

        return "\n".join(lines)


def main():
    """Main entry point for the CLI."""
    parser = argparse.ArgumentParser(
        description="Analyze project dependencies for feature implementation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Analyze dependencies for a feature
  python analyze_deps.py --feature user-authentication

  # Check for conflicts
  python analyze_deps.py --check-conflicts

  # List outdated dependencies
  python analyze_deps.py --list-outdated

  # Generate full report
  python analyze_deps.py --feature user-auth --output deps-report.md
        """,
    )

    parser.add_argument(
        "--feature", type=str, help="Name of the feature to analyze dependencies for"
    )

    parser.add_argument(
        "--output",
        type=Path,
        help="Output file for the report (Markdown format)",
    )

    parser.add_argument(
        "--check-conflicts",
        action="store_true",
        help="Check for dependency version conflicts",
    )

    parser.add_argument(
        "--list-outdated",
        action="store_true",
        help="List outdated dependencies",
    )

    parser.add_argument(
        "--project-root",
        type=Path,
        help="Root directory of the project (defaults to current directory)",
    )

    args = parser.parse_args()

    # Initialize analyzer
    analyzer = DependencyAnalyzer(project_root=args.project_root)

    # Execute requested analysis
    if args.check_conflicts:
        conflicts = analyzer.check_conflicts()
        if conflicts:
            print("\n⚠️  Conflicts detected:")
            for package, required, installed in conflicts:
                print(f"  - {package}: requires {required}, installed {installed}")
            sys.exit(1)
        else:
            print("✅ No conflicts detected")

    elif args.list_outdated:
        outdated = analyzer.list_outdated()
        if outdated:
            print("\n📦 Updates available:")
            for package, current, latest in outdated:
                print(f"  - {package}: {current} → {latest}")
        else:
            print("✅ All dependencies up-to-date")

    elif args.feature:
        report = analyzer.generate_report(args.feature, output_file=args.output)
        if not args.output:
            print("\n" + report)

    else:
        parser.print_help()
        print("\n⚠️  Please specify --feature, --check-conflicts, or --list-outdated")
        sys.exit(1)


if __name__ == "__main__":
    main()
